import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import { Context } from 'src/graphql/server';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  HexColorCode: any;
};

export enum FormatType {
  Hex = 'hex',
  Hsl = 'hsl',
  HslArray = 'hslArray',
  Hsla = 'hsla',
  HsvArray = 'hsvArray',
  Rgb = 'rgb',
  RgbArray = 'rgbArray',
  Rgba = 'rgba'
}

export enum Luminosity {
  Bright = 'bright',
  Dark = 'dark',
  Light = 'light'
}

export type Options = {
  /** A decimal between 0 and 1. Only relevant when using a format with an alpha channel (rgba and hsla). Defaults to a random value. */
  alpha?: InputMaybe<Scalars['Float']>;
  /** The color of the borders of each square. Defaults to #fff. */
  borderColor?: InputMaybe<Scalars['HexColorCode']>;
  /** The width of borders of each square. Defaults to 2. Set to 0 to disable. */
  borderWidth?: InputMaybe<Scalars['Float']>;
  /** A list of color hex codes to use. For example, ["#7b3357", "#ff00ff", "#000000"] */
  colors?: InputMaybe<Array<Scalars['HexColorCode']>>;
  /** How many colors to use. Defaults to 5. */
  count?: InputMaybe<Scalars['Int']>;
  /** The dimensions of the svg. Defaults to 20. */
  dimension?: InputMaybe<Scalars['Float']>;
  /** A string which specifies the format of the generated color. Possible values are rgb, rgba, rgbArray, hsl, hsla, hslArray and hex. Defaults to "hex". */
  format?: InputMaybe<FormatType>;
  /** The width of the svg. Defaults to width if not provided. */
  height?: InputMaybe<Scalars['Float']>;
  /** Controls the hue of the generated color. You can pass a string representing a color name: red, orange, yellow, green, blue, purple, pink and monochrome are currently supported. If you pass a hexidecimal color string such as #00FFFF, randomColor will extract its hue value and use that to generate colors. */
  hue?: InputMaybe<Scalars['String']>;
  /** Some combinations of letters and numbers. The cache's hashkey is generated by hashing the entire options object, including the 'id' field. This means that if you change options like colors or size, the hash will change and the svg will be regenerated, even if you pass the same id. */
  id?: InputMaybe<Scalars['ID']>;
  /** A short id used to identify the cached svg. If the svg does not exist in the cache, it will be generated and cached with this key. */
  key?: InputMaybe<Scalars['ID']>;
  /** Controls the luminosity of the generated color. You can specify a string containing bright, light or dark. */
  luminosity?: InputMaybe<Luminosity>;
  /** An integer or string which when passed will cause randomColor to return the same color each time. */
  seed?: InputMaybe<Scalars['ID']>;
  /** The size of each square. Defaults to 20. */
  size?: InputMaybe<Scalars['Int']>;
  /** A predetermined type of pattern will be generated. Defaults to "simple" */
  type?: InputMaybe<Type>;
  /** The width of the svg. Defaults to dimension if not provided. */
  width?: InputMaybe<Scalars['Float']>;
};

export type Query = {
  __typename?: 'Query';
  /** Generate an svg with the provided options */
  svg: Svg;
};


export type QuerySvgArgs = {
  options?: InputMaybe<Options>;
};

export type Svg = {
  __typename?: 'Svg';
  /** Data URI of the svg */
  data: Scalars['String'];
  /** URL of the generated svg */
  url: Scalars['String'];
};

export enum Type {
  Simple = 'simple'
}

export type WithIndex<TObject> = TObject & Record<string, any>;
export type ResolversObject<TObject> = WithIndex<TObject>;

export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info?: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info?: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info?: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info?: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info?: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info?: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = ResolversObject<{
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  Float: ResolverTypeWrapper<Scalars['Float']>;
  FormatType: FormatType;
  HexColorCode: ResolverTypeWrapper<Scalars['HexColorCode']>;
  ID: ResolverTypeWrapper<Scalars['ID']>;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  Luminosity: Luminosity;
  Options: Options;
  Query: ResolverTypeWrapper<{}>;
  String: ResolverTypeWrapper<Scalars['String']>;
  Svg: ResolverTypeWrapper<Svg>;
  Type: Type;
}>;

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = ResolversObject<{
  Boolean: Scalars['Boolean'];
  Float: Scalars['Float'];
  HexColorCode: Scalars['HexColorCode'];
  ID: Scalars['ID'];
  Int: Scalars['Int'];
  Options: Options;
  Query: {};
  String: Scalars['String'];
  Svg: Svg;
}>;

export interface HexColorCodeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['HexColorCode'], any> {
  name: 'HexColorCode';
}

export type QueryResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = ResolversObject<{
  svg?: Resolver<ResolversTypes['Svg'], ParentType, ContextType, Partial<QuerySvgArgs>>;
}>;

export type SvgResolvers<ContextType = Context, ParentType extends ResolversParentTypes['Svg'] = ResolversParentTypes['Svg']> = ResolversObject<{
  data?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
}>;

export type Resolvers<ContextType = Context> = ResolversObject<{
  HexColorCode?: GraphQLScalarType;
  Query?: QueryResolvers<ContextType>;
  Svg?: SvgResolvers<ContextType>;
}>;

